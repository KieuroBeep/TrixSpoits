-- Full script (fixed): true fullscreen "I Refuse..." shows for exactly 5 seconds (visible), then fades out.
-- Debounce prevents double-calls (so it won't restart/toggle twice from HealthChanged + Died).
-- Services
local Players = game:GetService("Players")
local ContentProvider = game:GetService("ContentProvider")
local RunService = game:GetService("RunService")
local ChatService = game:GetService("Chat")
local TweenService = game:GetService("TweenService")

-- Player references
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Clean up and create persistent UI
local existingGui = playerGui:FindFirstChild("ForcassNotifierGui")
if existingGui then existingGui:Destroy() end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ForcassNotifierGui"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global
screenGui.Parent = playerGui

-- Toggle button (kept from original)
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0, 120, 0, 50)
toggleButton.Position = UDim2.new(0.05, 0, 0.9, 0)
toggleButton.BackgroundColor3 = Color3.fromRGB(128, 0, 128)
toggleButton.TextColor3 = Color3.new(1, 1, 1)
toggleButton.Font = Enum.Font.GothamBold
toggleButton.TextSize = 20
toggleButton.Text = "OFF"
toggleButton.Parent = screenGui
Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0.5, 0)
toggleButton.ZIndex = 100000 -- ensure it renders above the fullscreen

-- Small notifier function (kept)
local function showNotifier(text)
    local frame = Instance.new("Frame", screenGui)
    frame.Size = UDim2.new(0, 250, 0, 50)
    frame.Position = UDim2.new(0.5, 0, 0.15, 0)
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.BackgroundColor3 = Color3.fromRGB(64, 0, 128)
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0.25, 0)
    frame.ZIndex = 100001

    local label = Instance.new("TextLabel", frame)
    label.Size = UDim2.new(1, -20, 1, 0)
    label.Position = UDim2.new(0, 10, 0, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextColor3 = Color3.new(1,1,1)
    label.Font = Enum.Font.GothamBold
    label.TextSize = 22
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.ZIndex = 100002

    task.delay(3, function()
        for i = 1, 20 do
            frame.BackgroundTransparency = i * 0.05
            label.TextTransparency = i * 0.05
            task.wait(0.1)
        end
        frame:Destroy()
    end)
end

showNotifier("Mady By Forcass Crd Kieuro")

-- Debounce flag so death GUI won't restart if both HealthChanged and Died fire
local deathGuiActive = false

-- Death fullscreen GUI (attached to same screenGui so toggleButton stays visible)
local function showDeathFullscreen(message, visibleDuration)
    visibleDuration = visibleDuration or 5

    if deathGuiActive then return end
    deathGuiActive = true

    -- Remove any existing one just in case (safe)
    if screenGui:FindFirstChild("ForcassDeathFrame") then
        screenGui.ForcassDeathFrame:Destroy()
    end

    -- Full screen black frame that truly covers the viewport but sits below the toggle button
    local frame = Instance.new("Frame")
    frame.Name = "ForcassDeathFrame"
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.Position = UDim2.new(0, 0, 0, 0)
    frame.AnchorPoint = Vector2.new(0, 0)
    frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    frame.BorderSizePixel = 0
    frame.BackgroundTransparency = 0
    frame.ZIndex = 50 -- keep low so toggleButton (ZIndex 100000) remains clickable/visible
    frame.Parent = screenGui
    frame.Active = false -- allow clicks to go to button above
    frame.Selectable = false

    -- Centered big text
    local label = Instance.new("TextLabel")
    label.Name = "RefuseLabel"
    label.Size = UDim2.new(0.9, 0, 0.4, 0)
    label.Position = UDim2.new(0.5, 0, 0.5, 0)
    label.AnchorPoint = Vector2.new(0.5, 0.5)
    label.BackgroundTransparency = 1
    label.Text = message or "I Refuse..."
    label.Font = Enum.Font.GothamBlack
    label.TextSize = 72
    label.TextScaled = true
    label.TextWrapped = true
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextTransparency = 0
    label.TextStrokeTransparency = 0.6
    label.ZIndex = 51
    label.Parent = frame

    -- Optional chat line (safe)
    pcall(function()
        if player.Character and player.Character:FindFirstChild("Head") then
            ChatService:Chat(player.Character.Head, message or "I Refuse...", Enum.ChatColor.White)
        end
    end)

    -- Visible for exactly visibleDuration seconds, then fade for 0.6s and destroy.
    task.spawn(function()
        -- wait visible period
        task.wait(visibleDuration)
        -- fade tween (0.6s)
        local tweenInfo = TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local tweenFrame = TweenService:Create(frame, tweenInfo, {BackgroundTransparency = 1})
        local tweenText = TweenService:Create(label, tweenInfo, {TextTransparency = 1, TextStrokeTransparency = 1})
        tweenFrame:Play()
        tweenText:Play()
        -- ensure we wait tween duration before destroying and clearing flag
        task.wait(0.6)
        if frame and frame.Parent then frame:Destroy() end
        deathGuiActive = false
    end)
end

-- Teleport-on-respawn logic (kept minimal)
local healthConn, diedConn
local teleportOnRespawn = false
local deathPosition = Vector3.new()

local function disconnectConnections()
    if healthConn then healthConn:Disconnect() end
    if diedConn then diedConn:Disconnect() end
end

-- Crown helpers (kept)
local function buildCrownMeshFromAccessory(accessory)
    if not accessory then return nil, nil end
    local handle = accessory:FindFirstChild("Handle")
    if not handle then return nil, nil end

    if handle:IsA("MeshPart") then
        return handle.MeshId, handle.TextureID
    end

    if handle:IsA("Part") then
        local sm = handle:FindFirstChildOfClass("SpecialMesh")
        if sm then
            return sm.MeshId, sm.TextureId
        end
    end
    return nil, nil
end

local CROWN_ASSET_ID = 82149395062733
local function crownEffect(character)
    local head = character:FindFirstChild("Head")
    if not head then return end

    local ok, asset = pcall(function()
        return game:GetObjects("rbxassetid://"..tostring(CROWN_ASSET_ID))[1]
    end)
    local accessory
    if ok and asset then
        if asset:IsA("Accessory") then
            accessory = asset
        else
            accessory = asset:FindFirstChildWhichIsA("Accessory")
        end
    end

    local meshId, textureId = buildCrownMeshFromAccessory(accessory)

    local crown = Instance.new("Part")
    crown.Name = "VFX_Crown"
    crown.Anchored = false
    crown.CanCollide = false
    crown.Transparency = 0
    crown.Size = Vector3.new(2,2,2)
    crown.Parent = character

    local motor = Instance.new("Motor6D")
    motor.Name = "CrownMotor"
    motor.Part0 = head
    motor.Part1 = crown
    motor.C0 = CFrame.new(0, 2.2, 0)
    motor.Parent = head

    local mesh = Instance.new("SpecialMesh")
    mesh.Parent = crown
    if meshId then
        mesh.MeshType = Enum.MeshType.FileMesh
        mesh.MeshId = meshId
        if textureId and textureId ~= "" then
            mesh.TextureId = textureId
        end
    else
        mesh.MeshType = Enum.MeshType.Cylinder
    end
    mesh.Scale = Vector3.new(4,4,4)

    local att = Instance.new("Attachment")
    att.Parent = crown
    local p = Instance.new("ParticleEmitter")
    p.Parent = att
    p.Rate = 50
    p.Lifetime = NumberRange.new(1, 2)
    p.Speed = NumberRange.new(0.5, 2)
    p.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1.5),
        NumberSequenceKeypoint.new(1, 0)
    })
    p.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.1),
        NumberSequenceKeypoint.new(1, 1)
    })
    p.Color = ColorSequence.new(Color3.fromRGB(0,0,0))
    p.SpreadAngle = Vector2.new(360,360)

    local alive = true
    local t = 0
    local spinConn
    spinConn = RunService.RenderStepped:Connect(function(dt)
        if not alive or not motor.Parent then return end
        t = t + dt
        motor.C0 = CFrame.new(0, 2.2, 0) * CFrame.Angles(0, math.rad(t * 180), 0)
    end)

    task.delay(4, function()
        for i = 1, 20 do
            mesh.Scale = mesh.Scale * 0.85
            task.wait(0.05)
        end
        alive = false
        if spinConn then spinConn:Disconnect() end
        if motor then motor:Destroy() end
        if crown then crown:Destroy() end
        if accessory then accessory:Destroy() end
    end)
end

-- Preload aura animation (kept)
local auraAnimation = Instance.new("Animation")
auraAnimation.AnimationId = "rbxassetid://114586157428274"
ContentProvider:PreloadAsync({auraAnimation})

-- Character added setup: connect health and death events
local function onCharacterAdded(character)
    local humanoid = character:WaitForChild("Humanoid")
    disconnectConnections()

    healthConn = humanoid.HealthChanged:Connect(function(health)
        if health <= 0 then
            local root = character:FindFirstChild("HumanoidRootPart")
            if root then
                deathPosition = root.Position
                teleportOnRespawn = true
            end
            pcall(function()
                showDeathFullscreen("I Refuse...", 5) -- visible for exactly 5s then fade
            end)
        end
    end)

    diedConn = humanoid.Died:Connect(function()
        local root = character:FindFirstChild("HumanoidRootPart")
        if root then
            deathPosition = root.Position
            teleportOnRespawn = true
        end
        pcall(function()
            showDeathFullscreen("I Refuse...", 5)
        end)
    end)
end

-- On respawn: play aura, crown, teleport if needed
local function onRespawn(character)
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)

    if teleportOnRespawn and deathPosition.Magnitude > 0 then
        rootPart.CFrame = CFrame.new(deathPosition)
        teleportOnRespawn = false
        deathPosition = Vector3.new()
        showNotifier("But I Refuse")
        pcall(function()
            if character:FindFirstChild("Head") then
                ChatService:Chat(character.Head, "I refuse to die to a weekling like you!", Enum.ChatColor.Red)
            end
        end)
    end

    local success, animTrack = pcall(function()
        return animator:LoadAnimation(auraAnimation)
    end)
    if success and animTrack then
        animTrack.Priority = Enum.AnimationPriority.Action
        animTrack:Play()
    end

    local auraHighlight = Instance.new("Highlight", character)
    auraHighlight.Adornee = character
    auraHighlight.FillTransparency = 1
    auraHighlight.OutlineTransparency = 0
    auraHighlight.OutlineColor = Color3.fromRGB(255, 0, 255)

    local colorTime = 0
    local highlightLoop = RunService.RenderStepped:Connect(function(dt)
        colorTime = colorTime + dt * 0.25
        auraHighlight.OutlineColor = Color3.fromRGB(
            math.sin(colorTime)*127 + 128,
            math.sin(colorTime+2)*127 + 128,
            math.sin(colorTime+4)*127 + 128
        )
    end)

    local particles = {}
    for _, partName in ipairs({"UpperTorso","LowerTorso","HumanoidRootPart"}) do
        local part = character:FindFirstChild(partName)
        if part then
            local att = Instance.new("Attachment", part)
            local p = Instance.new("ParticleEmitter", att)
            p.Name = "DarkAura"
            p.Rate = 30
            p.Lifetime = NumberRange.new(1.2, 2)
            p.Speed = NumberRange.new(2, 5)
            p.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,3), NumberSequenceKeypoint.new(1,0)})
            p.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.1), NumberSequenceKeypoint.new(1,1)})
            p.Color = ColorSequence.new(Color3.fromRGB(15,15,15))
            p.Rotation = NumberRange.new(0, 360)
            p.RotSpeed = NumberRange.new(-90, 90)
            p.SpreadAngle = Vector2.new(180,180)
            p.ZOffset = -1
            table.insert(particles, p)
        end
    end

    crownEffect(character)

    task.delay(4, function()
        if success and animTrack and animTrack.IsPlaying then animTrack:Stop() end
        if success and animTrack then
            pcall(function() animTrack:Destroy() end)
        end
        if auraHighlight and auraHighlight.Parent then pcall(function() auraHighlight:Destroy() end) end
        if highlightLoop then highlightLoop:Disconnect() end
        for _, p in ipairs(particles) do
            if p then p:Destroy() end
        end
    end)

    -- Reconnect health/death watchers
    onCharacterAdded(character)
end

-- Activation logic
local scriptActive = false
local characterAddedConnection

local function activateScript()
    if scriptActive then return end
    scriptActive = true
    toggleButton.Text = "ON"
    teleportOnRespawn = false
    deathPosition = Vector3.new()

    if not characterAddedConnection then
        characterAddedConnection = player.CharacterAdded:Connect(onRespawn)
    end
    if player.Character then onRespawn(player.Character) end

    showNotifier("Script loaded")
end

local function deactivateScript()
    if not scriptActive then return end
    scriptActive = false
    toggleButton.Text = "OFF"
    disconnectConnections()
    teleportOnRespawn = false
    deathPosition = Vector3.new()
    showNotifier("Script deactivated")
end

toggleButton.MouseButton1Click:Connect(function()
    if scriptActive then deactivateScript() else activateScript() end
end)

-- Initialize OFF
deactivateScript()

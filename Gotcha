loadstring(game:HttpGet("https://raw.githubusercontent.com/KieuroBeep/TrixSpoits/refs/heads/main/Whitepad"))()
local WindUI
do
local ok, result = pcall(function()
return require("./src/Init")
end)
if ok then
        WindUI = result
else
        WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end
end
-- Executor check
local executor = identifyexecutor() or getexecutorname() or "Unknown"
local badExecutors = {"Radius", "Nihon", "JJsploit"}
local isBadExecutor = false
for _, bad in ipairs(badExecutors) do
if executor:lower():find(bad:lower()) then
        isBadExecutor = true
break
end
end
if isBadExecutor then
-- Warning GUI
local warningGui = Instance.new("ScreenGui")
    warningGui.Name = "DiabloWarningUI"
    warningGui.Parent = game.Players.LocalPlayer.PlayerGui
    warningGui.ResetOnSpawn = false
local warningFrame = Instance.new("Frame")
    warningFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    warningFrame.BorderSizePixel = 0
    warningFrame.Position = UDim2.new(0.5, -200, 0.5, -100)
    warningFrame.Size = UDim2.new(0, 400, 0, 200)
    warningFrame.Parent = warningGui
local UICornerWarning = Instance.new("UICorner")
    UICornerWarning.CornerRadius = UDim.new(0.1, 0)
    UICornerWarning.Parent = warningFrame
local warningLabel = Instance.new("TextLabel")
    warningLabel.BackgroundTransparency = 1
    warningLabel.Position = UDim2.new(0, 0, 0.1, 0)
    warningLabel.Size = UDim2.new(1, 0, 0.8, 0)
    warningLabel.Font = Enum.Font.SourceSansBold
    warningLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
    warningLabel.TextSize = 20
    warningLabel.TextWrapped = true
    warningLabel.Text = "your executor is not yet Supported Some Features may bugged out or wont work Change your executor for better capabilities"
    warningLabel.TextXAlignment = Enum.TextXAlignment.Center
    warningLabel.Parent = warningFrame
wait(math.random(3, 5))
    warningGui:Destroy()
end
-- Loading UI
local loadingGui = Instance.new("ScreenGui")
loadingGui.Name = "DiabloLoadingUI"
loadingGui.Parent = game.Players.LocalPlayer.PlayerGui
loadingGui.ResetOnSpawn = false
local loadingFrame = Instance.new("Frame")
loadingFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
loadingFrame.BorderSizePixel = 0
loadingFrame.Position = UDim2.new(0.5, -150, 0.5, -75)
loadingFrame.Size = UDim2.new(0, 300, 0, 150)
loadingFrame.Parent = loadingGui
local UICornerLoading = Instance.new("UICorner")
UICornerLoading.CornerRadius = UDim.new(0.1, 0)
UICornerLoading.Parent = loadingFrame
local welcomeLabel = Instance.new("TextLabel")
welcomeLabel.BackgroundTransparency = 1
welcomeLabel.Position = UDim2.new(0, 0, 0.2, 0)
welcomeLabel.Size = UDim2.new(1, 0, 0.3, 0)
welcomeLabel.Font = Enum.Font.SourceSansBold
welcomeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
welcomeLabel.TextSize = 24
welcomeLabel.Text = "Welcome to Diablo Hub"
welcomeLabel.TextXAlignment = Enum.TextXAlignment.Center
welcomeLabel.Parent = loadingFrame
local loadingLabel = Instance.new("TextLabel")
loadingLabel.BackgroundTransparency = 1
loadingLabel.Position = UDim2.new(0, 0, 0.5, 0)
loadingLabel.Size = UDim2.new(1, 0, 0.3, 0)
loadingLabel.Font = Enum.Font.SourceSansBold
loadingLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
loadingLabel.TextSize = 18
loadingLabel.Text = "Loading..."
loadingLabel.TextXAlignment = Enum.TextXAlignment.Center
loadingLabel.Parent = loadingFrame
-- Loading animation
local dotsCount = 0
spawn(function()
while loadingGui.Parent do
        dotsCount = (dotsCount % 3) + 1
        loadingLabel.Text = "Loading" .. ("."):rep(dotsCount)
wait(0.5)
end
end)
wait(3) -- Simulate loading time
loadingGui:Destroy()
-- Window
local Window = WindUI:CreateWindow({
    Title = "YBA Script | Free Version",
    Icon = "cat",
    Author = "by Diablo",
    Folder = "yba_script",
    NewElements = true,
    HideSearchBar = false,
    OpenButton = {
        Title = "Open Diablo UI", -- can be changed
        CornerRadius = UDim.new(1,0), -- fully rounded
        StrokeThickness = 3, -- removing outline
        Enabled = true, -- enable or disable openbutton
        Draggable = true,
        OnlyMobile = false,
        Color = ColorSequence.new( -- gradient
            Color3.fromHex("#30FF6A"),
            Color3.fromHex("#e7ff2f")
)
}
})
Window:SetToggleKey(Enum.KeyCode.K)
-- */ Other Functions /* --
local function parseJSON(luau_table, indent, level, visited)
    indent = indent or 2
    level = level or 0
    visited = visited or {}
local currentIndent = string.rep(" ", level * indent)
local nextIndent = string.rep(" ", (level + 1) * indent)
if luau_table == nil then
return "null"
end
local dataType = type(luau_table)
if dataType == "table" then
if visited[luau_table] then
return "\"[Circular Reference]\""
end
        visited[luau_table] = true
local isArray = true
local maxIndex = 0
for k, _ in pairs(luau_table) do
if type(k) == "number" and k > maxIndex then
                maxIndex = k
end
if type(k) ~= "number" or k <= 0 or math.floor(k) ~= k then
                isArray = false
break
end
end
local count = 0
for _ in pairs(luau_table) do
            count = count + 1
end
if count ~= maxIndex and isArray then
            isArray = false
end
if count == 0 then
return "{}"
end
if isArray then
if count == 0 then
return "[]"
end
local result = "[\n"
for i = 1, maxIndex do
                result = result .. nextIndent .. parseJSON(luau_table[i], indent, level + 1, visited)
if i < maxIndex then
                    result = result .. ","
end
                result = result .. "\n"
end
            result = result .. currentIndent .. "]"
return result
else
local result = "{\n"
local first = true
local keys = {}
for k in pairs(luau_table) do
                table.insert(keys, k)
end
            table.sort(keys, function(a, b)
if type(a) == type(b) then
return tostring(a) < tostring(b)
else
return type(a) < type(b)
end
end)
for _, k in ipairs(keys) do
local v = luau_table[k]
if not first then
                    result = result .. ",\n"
else
                    first = false
end
if type(k) == "string" then
                    result = result .. nextIndent .. "\"" .. k .. "\": "
else
                    result = result .. nextIndent .. "\"" .. tostring(k) .. "\": "
end
                result = result .. parseJSON(v, indent, level + 1, visited)
end
            result = result .. "\n" .. currentIndent .. "}"
return result
end
elseif dataType == "string" then
local escaped = luau_table:gsub("\\", "\\\\")
        escaped = escaped:gsub("\"", "\\\"")
        escaped = escaped:gsub("\n", "\\n")
        escaped = escaped:gsub("\r", "\\r")
        escaped = escaped:gsub("\t", "\\t")
return "\"" .. escaped .. "\""
elseif dataType == "number" then
return tostring(luau_table)
elseif dataType == "boolean" then
return luau_table and "true" or "false"
elseif dataType == "function" then
return "\"function\""
else
return "\"" .. dataType .. "\""
end
end
local function tableToClipboard(luau_table, indent)
    indent = indent or 4
local jsonString = parseJSON(luau_table, indent)
    setclipboard(jsonString)
return jsonString
end
-- Tabs
local AboutTab = Window:Tab({
    Title = "About",
    Icon = "info",
})
local AboutSection = AboutTab:Section({
    Title = "About YBA Script",
})
AboutSection:Image({
    Image = "rbxassetid://7307851339",
    AspectRatio = "16:9",
    Radius = 9,
})
local titleLabel = Instance.new("TextLabel")
titleLabel.BackgroundTransparency = 1
titleLabel.Size = UDim2.new(0, 200, 0, 50)
titleLabel.Position = UDim2.new(0.5, 0, 0, 0) -- Adjust position to be beside the image
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
titleLabel.TextSize = 24
titleLabel.Text = "YBA Script"
titleLabel.Parent = AboutSection.Element -- Assuming Element is the frame, adjust if needed
local authorLabel = Instance.new("TextLabel")
authorLabel.BackgroundTransparency = 1
authorLabel.Size = UDim2.new(0, 200, 0, 30)
authorLabel.Position = UDim2.new(0.5, 0, 0.1, 0) -- Under the title
authorLabel.Font = Enum.Font.SourceSans
authorLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
authorLabel.TextSize = 18
authorLabel.Text = "by Diablo"
authorLabel.Parent = AboutSection.Element
AboutSection:Space({ Columns = 3 })
AboutSection:Section({
    Title = "YBA Script by Diablo",
    TextSize = 24,
    FontWeight = Enum.FontWeight.SemiBold,
})
AboutSection:Space()
AboutSection:Section({
    Title = "This is a script for YBA with farming, selling, and more features. UI powered by WindUI. Made by Diablo. Tips: Use Normal farming for safe play, AFK for faster but riskier. Sell worthless items regularly. Adjust speed for optimal performance. Who made it: Diablo, with contributions from the community.",
    TextSize = 18,
    TextTransparency = .35,
    FontWeight = Enum.FontWeight.Medium,
})
local FarmingTab = Window:Tab({ Title = "Farming", Icon = "skull" })
local SellingTab = Window:Tab({ Title = "Selling", Icon = "dollar-sign" })
local VisualTab = Window:Tab({ Title = "Visual", Icon = "eye" })
local MiscTab = Window:Tab({ Title = "Misc", Icon = "zap" })
local AdjustTab = Window:Tab({ Title = "Adjust", Icon = "sliders-horizontal" })
local LevelFarmTab = Window:Tab({ Title = "Level Farm", Icon = "arrow-up" })
local TrollingTab = Window:Tab({ Title = "Trolling", Icon = "smile" })
local SettingsTab = Window:Tab({ Title = "Settings", Icon = "settings" })
local player = game.Players.LocalPlayer
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
-- Top Status Bar (Diablo UI)
local topGui = Instance.new("ScreenGui")
topGui.Name = "DiabloUI"
topGui.Parent = player.PlayerGui
topGui.ResetOnSpawn = false
topGui.Enabled = true
local statusFrame = Instance.new("Frame")
statusFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
statusFrame.BackgroundTransparency = 0.5
statusFrame.BorderSizePixel = 0
statusFrame.Position = UDim2.new(0.5, -150, 0, 5)
statusFrame.Size = UDim2.new(0, 300, 0, 60)
statusFrame.Parent = topGui
local UICornerFrame = Instance.new("UICorner")
UICornerFrame.CornerRadius = UDim.new(0.1, 0)
UICornerFrame.Parent = statusFrame
local statusLabel = Instance.new("TextLabel")
statusLabel.BackgroundTransparency = 1
statusLabel.Position = UDim2.new(0, 0, 0, 0)
statusLabel.Size = UDim2.new(1, -30, 0.5, 0)
statusLabel.Font = Enum.Font.SourceSansBold
statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
statusLabel.TextSize = 18
statusLabel.TextXAlignment = Enum.TextXAlignment.Center
statusLabel.Parent = statusFrame
local creditLabel = Instance.new("TextLabel")
creditLabel.BackgroundTransparency = 1
creditLabel.Position = UDim2.new(0, 0, 0.5, 0)
creditLabel.Size = UDim2.new(1, -30, 0.5, 0)
creditLabel.Font = Enum.Font.SourceSansBold
creditLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
creditLabel.TextSize = 14
creditLabel.TextXAlignment = Enum.TextXAlignment.Center
creditLabel.Parent = statusFrame
local hideButton = Instance.new("TextButton")
hideButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
hideButton.BackgroundTransparency = 0.5
hideButton.BorderSizePixel = 0
hideButton.Position = UDim2.new(1, -30, 0, 0)
hideButton.Size = UDim2.new(0, 30, 0, 30)
hideButton.Font = Enum.Font.SourceSansBold
hideButton.TextColor3 = Color3.fromRGB(255, 255, 255)
hideButton.TextSize = 18
hideButton.Text = "X"
hideButton.Parent = statusFrame
hideButton.MouseButton1Click:Connect(function()
    topGui.Enabled = false
end)
local UICornerButton = Instance.new("UICorner")
UICornerButton.CornerRadius = UDim.new(0.1, 0)
UICornerButton.Parent = hideButton
local fps = 0
local timeAccum = 0
local frameCount = 0
RunService.RenderStepped:Connect(function(delta)
    frameCount = frameCount + 1
    timeAccum = timeAccum + delta
if timeAccum >= 1 then
        fps = math.floor(frameCount / timeAccum)
        frameCount = 0
        timeAccum = 0
end
end)
local dotsCount = 0
spawn(function()
while true do
if topGui.Enabled then
            statusLabel.Text = "| " .. player.Name .. " | FPS: " .. fps
            dotsCount = (dotsCount % 3) + 1
            creditLabel.Text = "This script is made by Diablo" .. ("."):rep(dotsCount)
end
wait(0.5)
end
end)
-- Notification Function
local function notify(title, message)
    title = title or "YBA Script"
    WindUI:Notify({
        Title = title,
        Content = message
    })
end
-- Item Lists (copied from old script)
local items = {}
local maxLimits = { -- Add to the list if I missed an item
["Mysterious Arrow"] = 25,
["Rokakaka"] = 25,
["Gold Coin"] = 45,
["Diamond"] = 25,
["Pure Rokakaka"] = 10,
["Quinton's Glove"] = 10,
["Steel Ball"] = 10,
["Rib Cage of The Saint's Corpse"] = 10,
["Zepellin's Headband"] = 10,
["Zeppeli's Hat"] = 10,
["Caesar's Headband"] = 10,
["Clackers"] = 10,
["Stone Mask"] = 10,
["Ancient Scroll"] = 10,
["Dio's Diary"] = 10,
["Pure Rokakaka"] = 999,
["Lucky Stone Mask"] = 999,
["Lucky Arrow"] = 999,
["Gold Umbrella"] = 999,
["Left Arm of The Saint's Corpse"] = 999,
["Heart of The Saint's Corpse"] = 999,
["Pelvis of The Saint's Corpse"] = 999
}
local nonSellable = {"Blue Candy", "Red Candy", "Green Candy", "Yellow Candy"}
local itemOptions = {}
for item in pairs(maxLimits) do
    table.insert(itemOptions, item)
end
for _, candy in ipairs(nonSellable) do
    table.insert(itemOptions, candy)
end
table.sort(itemOptions)
local worthlessItems = {"Gold Coin", "Diamond", "Quinton's Glove", "Zeppeli's Hat", "Caesar's Headband", "Ancient Scroll"}
-- Function to count items (Backpack + Character)
local function updateItems()
    items = {}
for itemName in pairs(maxLimits) do
        items[itemName] = 0
end
local function countInContainer(container)
if not container then return end
for _, item in pairs(container:GetChildren()) do
if item and item.Name and maxLimits[item.Name] then
                items[item.Name] = (items[item.Name] or 0) + 1
end
end
end
    countInContainer(player.Backpack)
if player.Character then
        countInContainer(player.Character)
end
end
-- Helper: tries to locate a RemoteEvent to fire the selling args on
local function findSellRemote()
local plr = game.Players.LocalPlayer
-- Check character first
if plr and plr.Character then
for _, obj in pairs(plr.Character:GetChildren()) do
if obj:IsA("RemoteEvent") then
return obj
end
end
end
-- Search common places
local places = {game.Workspace, game.ReplicatedStorage, game:GetService("ReplicatedStorage"), game:GetService("Players")}
for _, place in pairs(places) do
if place then
for _, obj in pairs(place:GetDescendants()) do
if obj:IsA("RemoteEvent") and (obj.Name:lower():find("remote") or obj.Name:lower():find("remoteevent") or obj.Name:lower():find("sell") or obj.Name:lower():find("server") or obj.Name:lower():find("_ev")) then
return obj
end
end
end
end
-- Last fallback: any RemoteEvent in workspace root
for _, obj in pairs(game.Workspace:GetChildren()) do
if obj:IsA("RemoteEvent") then
return obj
end
end
return nil
end
-- Sell Item Function (robust: accepts Instance or string name)
local function sellItem(item)
if not item then return false end
local itemName = typeof(item) == "Instance" and item.Name or item
if table.find(nonSellable, itemName) then
        notify("YBA Script", "Cannot sell " .. itemName .. " as it is not sellable.")
return false
end
local plr = game.Players.LocalPlayer
if not plr then return false end
local instanceToSell
if typeof(item) == "Instance" then
        instanceToSell = item
elseif typeof(item) == "string" then
        instanceToSell = plr.Backpack:FindFirstChild(item) or (plr.Character and plr.Character:FindFirstChild(item))
else
return false
end
if not instanceToSell or not instanceToSell.Parent then
return false
end
-- Parent the item to the player's living (if present) or workspace
local plrName = plr.Name
local living = game.Workspace:FindFirstChild("Living") or game.Workspace
local target = nil
if living then
        target = living:FindFirstChild(plrName) or living
else
        target = game.Workspace
end
pcall(function()
        instanceToSell.Parent = target
end)
-- Prepare server args (keeps original EndDialogue structure)
local args = {
[1] = "EndDialogue",
[2] = {
["NPC"] = "Merchant",
["Option"] = "Option2",
["Dialogue"] = "Dialogue5"
}
}
-- Try to find and fire a RemoteEvent safely
local fired = false
local ok, remote = pcall(findSellRemote)
if ok and remote then
pcall(function()
            remote:FireServer(unpack(args))
end)
        fired = true
else
if plr.Character then
local r = plr.Character:FindFirstChildWhichIsA("RemoteEvent")
if r then
pcall(function()
                    r:FireServer(unpack(args))
end)
                fired = true
end
end
end
pcall(function()
if not fired and plr.Character and plr.Character:FindFirstChild("RemoteEvent") then
            plr.Character.RemoteEvent:FireServer(unpack(args))
            fired = true
end
end)
wait(0.12) -- small delay to reduce rate-limit issues
return true
end
-- Helper to sell all of a specific item with smart notify
local function sellAll(itemName)
    updateItems()
local count = items[itemName] or 0
if count == 0 then
        notify("YBA Script", "No " .. itemName .. " found.")
return
end
local sold = 0
while true do
local item = player.Backpack:FindFirstChild(itemName) or (player.Character and player.Character:FindFirstChild(itemName))
if not item then break end
if sellItem(item) then
            sold = sold + 1
else
break
end
end
    notify("YBA Script", "Sold " .. sold .. " " .. itemName .. (sold > 1 and "s" or "") .. ".")
end
-- Sell all selected with smart notify
local function sellAllSelected(selectedItems)
    updateItems()
local total = 0
for _, itemName in ipairs(selectedItems) do
        total = total + (items[itemName] or 0)
end
if total == 0 then
        notify("YBA Script", "No selected items found.")
return
end
local sold = 0
for _, itemName in ipairs(selectedItems) do
while true do
local item = player.Backpack:FindFirstChild(itemName) or (player.Character and player.Character:FindFirstChild(itemName))
if not item then break end
if sellItem(item) then
                sold = sold + 1
else
break
end
end
end
    notify("YBA Script", "Sold " .. sold .. " selected item" .. (sold > 1 and "s" or "") .. ".")
end
-- Sell all worthless with smart notify
local function sellAllWorthless()
    updateItems()
local total = 0
for _, itemName in ipairs(worthlessItems) do
        total = total + (items[itemName] or 0)
end
if total == 0 then
        notify("YBA Script", "No worthless items found.")
return
end
local sold = 0
for _, itemName in ipairs(worthlessItems) do
while true do
local item = player.Backpack:FindFirstChild(itemName) or (player.Character and player.Character:FindFirstChild(itemName))
if not item then break end
if sellItem(item) then
                sold = sold + 1
else
break
end
end
end
    notify("YBA Script", "Sold " .. sold .. " worthless item" .. (sold > 1 and "s" or "") .. ".")
end
-- Sell entire inventory (all sellable items)
local function sellInventory()
    updateItems()
local sold = 0
for itemName, count in pairs(items) do
if count > 0 and not table.find(nonSellable, itemName) then
while true do
local item = player.Backpack:FindFirstChild(itemName) or (player.Character and player.Character:FindFirstChild(itemName))
if not item then break end
if sellItem(item) then
                    sold = sold + 1
else
break
end
end
end
end
    notify("YBA Script", "Sold " .. sold .. " item" .. (sold > 1 and "s" or "") .. " from inventory.")
end
-- Auto Sell on Max (copied logic from old script)
local autoSellMax = false
local function checkAndSellMax()
local soldSummary = {}
local tempCounts = {}
for name in pairs(maxLimits) do
        tempCounts[name] = 0
end
local containers = {player.Backpack}
if player.Character then
        table.insert(containers, player.Character)
end
for _, container in ipairs(containers) do
local children = container:GetChildren() -- Snapshot
for _, item in ipairs(children) do
local name = item.Name
if maxLimits[name] then
                tempCounts[name] = tempCounts[name] + 1
if (tempCounts[name] >= (maxLimits[name] or 25)) and autoSellMax then
if sellItem(item) then
                        soldSummary[name] = (soldSummary[name] or 0) + 1
end
end
end
end
end
-- Send consolidated notification
local totalSold = 0
local parts = {}
for name, n in pairs(soldSummary) do
        totalSold = totalSold + n
        table.insert(parts, n .. "x " .. name)
end
if totalSold > 0 then
local msg = "Auto sold: " .. table.concat(parts, ", ")
        notify("YBA Script", msg)
end
end
-- Auto Sell Selected
local autoSellSelected = false
local selectedAutoSellItems = {}
local selectedSellAllItems = {}
local lastAutoSellNotify = {}
player.Backpack.ChildAdded:Connect(function(item)
if autoSellMax then
        checkAndSellMax()
end
if autoSellSelected and table.find(selectedAutoSellItems, item.Name) then
wait(0.2) -- Added delay to allow the item to fully register before selling
local now = tick()
local last = lastAutoSellNotify[item.Name] or 0
if now - last >= 0.5 then
if sellItem(item) then
                notify("YBA Script", "Auto sold " .. item.Name .. " on pickup.")
                lastAutoSellNotify[item.Name] = now
end
end
end
end)
-- Also watch Character (some servers parent pickups to Character)
player.CharacterAdded:Connect(function(char)
    char.ChildAdded:Connect(function(item)
if autoSellMax then
            checkAndSellMax()
end
if autoSellSelected and table.find(selectedAutoSellItems, item.Name) then
wait(0.2) -- Added delay to allow the item to fully register before selling
local now = tick()
local last = lastAutoSellNotify[item.Name] or 0
if now - last >= 0.5 then
if sellItem(item) then
                    notify("YBA Script", "Auto sold " .. item.Name .. " on pickup.")
                    lastAutoSellNotify[item.Name] = now
end
end
end
end)
end)
-- Noclip Functionality
local noclip = false
local noclipConnection
local function enableNoclip()
    noclip = true
    noclipConnection = RunService.Stepped:Connect(function()
if noclip and player.Character then
for _, part in pairs(player.Character:GetDescendants()) do
if part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
end
end
end
end)
end
local function disableNoclip()
    noclip = false
if noclipConnection then
        noclipConnection:Disconnect()
end
if player.Character then
for _, part in pairs(player.Character:GetDescendants()) do
if part:IsA("BasePart") then
                part.CanCollide = true
end
end
end
end
-- TP Function (Stud)
local speedValue = 1
local function travelToStud(target)
if not player.Character or not player.Character.HumanoidRootPart then return end
local hrp = player.Character.HumanoidRootPart
local targetPos = typeof(target) == "Vector3" and target or target.Position
local vector = targetPos - hrp.Position
local length = vector.Magnitude
local step_size = (afkFarmOn and 5 or 50) * speedValue
local num_tp = math.ceil(length / step_size)
if num_tp < 1 then num_tp = 1 end
for i = 1, num_tp do
if not player.Character or not player.Character.HumanoidRootPart then return end
        hrp.CFrame = hrp.CFrame + vector / num_tp
wait(tpDelay)
end
end
-- TP Function (Tween)
local function travelToTween(target)
if not player.Character or not player.Character.HumanoidRootPart then return end
local hrp = player.Character.HumanoidRootPart
local targetPos = typeof(target) == "Vector3" and target or target.Position
local tweenInfo = TweenInfo.new(0.5 / speedValue, Enum.EasingStyle.Linear)
local tween = TweenService:Create(hrp, tweenInfo, {CFrame = CFrame.new(targetPos)})
    tween:Play()
    tween.Completed:Wait()
end
-- Selected Travel Function
local travelMethod = "Stud"
local function travelTo(target)
if travelMethod == "Stud" then
        travelToStud(target)
elseif travelMethod == "Tween" then
        travelToTween(target)
end
end
-- Random TP Functions
local function teleportToRandom()
local map = game.Workspace:FindFirstChild("Map") or game.Workspace
local bounds = {
        minX = -590, maxX = 590,
        minZ = -520, maxZ = 530,
        y = 100 -- Adjust based on map height
}
local randomX = math.random(bounds.minX, bounds.maxX)
local randomZ = math.random(bounds.minZ, bounds.maxZ)
if not player.Character or not player.Character.HumanoidRootPart then return end
local hrp = player.Character.HumanoidRootPart
    hrp.CFrame = CFrame.new(randomX, bounds.y, randomZ)
end
local function roamToRandom()
local map = game.Workspace:FindFirstChild("Map") or game.Workspace
local bounds = {
        minX = -590, maxX = 590,
        minZ = -520, maxZ = 530,
        y = 100 -- Adjust based on map height
}
local randomX = math.random(bounds.minX, bounds.maxX)
local randomZ = math.random(bounds.minZ, bounds.maxZ)
local randomPos = Vector3.new(randomX, bounds.y, randomZ)
    travelTo(randomPos)
end
local normalFarmOn = false
local afkFarmOn = false
local selectedFarmItems = {}
local normalCoroutine = nil
local afkCoroutine = nil
local tpDelay = 0.05 -- Default delay
local originalTpDelay = 0.05
-- Normal Farming (old AFK)
local function normalFarm()
while normalFarmOn do
if not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0 then
wait(1)
            continue
end
local foundItem = false
for _, v in pairs(game.Workspace.Item_Spawns.Items:GetChildren()) do
local itemPart = v:FindFirstChildOfClass("MeshPart") or v:FindFirstChildOfClass("Part")
local proxPrompt = v:FindFirstChild("ProximityPrompt")
if itemPart and proxPrompt and itemPart.Transparency < 1 and (#selectedFarmItems == 0 or table.find(selectedFarmItems, proxPrompt.ObjectText)) then -- Changed to <1 to avoid invisible
                    foundItem = true
if instantPickup then
                        instantTravelTo(itemPart)
wait(0.08) -- small delay for position sync
                        checkAndSellMax()
                        fireproximityprompt(proxPrompt, 0, true) -- force
else
                        travelTo(itemPart)
local hrp = player.Character.HumanoidRootPart
if (itemPart.Position - hrp.Position).Magnitude < 5 then
                            checkAndSellMax()
                            fireproximityprompt(proxPrompt, 4)
wait(0.1) -- Wait briefly
if v:IsDescendantOf(game.Workspace) then
                                fireproximityprompt(proxPrompt, 4) -- Try again if not picked
end
end
end
                    checkAndSellMax()
end
end
if not foundItem then
            teleportToRandom()
end
wait(0.2) -- Faster loop for better detection
end
end
-- AFK Farming (old Gravel, improved roaming)
local function afkFarm()
while afkFarmOn do
if not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0 then
wait(1)
            continue
end
local roaming = true
while roaming and afkFarmOn do
if not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0 then
break
end
-- Check for items constantly
local foundItem = false
for _, v in pairs(game.Workspace.Item_Spawns.Items:GetChildren()) do
local itemPart = v:FindFirstChildOfClass("MeshPart") or v:FindFirstChildOfClass("Part")
local proxPrompt = v:FindFirstChild("ProximityPrompt")
if itemPart and proxPrompt and itemPart.Transparency < 1 and (#selectedFarmItems == 0 or table.find(selectedFarmItems, proxPrompt.ObjectText)) then -- Changed to <1
                        foundItem = true
                        roaming = false
if instantPickup then
                            instantTravelTo(itemPart)
wait(0.08)
                            checkAndSellMax()
                            fireproximityprompt(proxPrompt, 0, true)
else
                            travelTo(itemPart)
local hrp = player.Character.HumanoidRootPart
if (itemPart.Position - hrp.Position).Magnitude < 5 then
                                checkAndSellMax()
                                fireproximityprompt(proxPrompt, 4)
wait(0.1) -- Wait briefly
if v:IsDescendantOf(game.Workspace) then
                                    fireproximityprompt(proxPrompt, 4) -- Try again if not picked
end
end
end
                        checkAndSellMax()
                        roaming = true
break
end
end
if not foundItem then
                roamToRandom()
end
wait(0.05) -- Even faster check
end
end
end
-- Handle respawn for farming
local function startFarming(method)
if method == "Normal" then
        normalFarmOn = true
        normalCoroutine = coroutine.wrap(normalFarm)()
elseif method == "AFK Farming" then
        afkFarmOn = true
        afkCoroutine = coroutine.wrap(afkFarm)()
end
    enableNoclip()
end
local function stopFarming()
    normalFarmOn = false
    afkFarmOn = false
    disableNoclip()
end
player.CharacterAdded:Connect(function(char)
if normalFarmOn or afkFarmOn then
wait(2) -- Wait for full load
        enableNoclip()
if normalFarmOn then
if normalCoroutine then coroutine.close(normalCoroutine) end
            normalCoroutine = coroutine.wrap(normalFarm)()
elseif afkFarmOn then
if afkCoroutine then coroutine.close(afkCoroutine) end
            afkCoroutine = coroutine.wrap(afkFarm)()
end
end
end)
-- Item ESP
local itemESP = false
local espConnection
local function addItemESP(v)
local itemPart = v:FindFirstChildOfClass("MeshPart") or v:FindFirstChildOfClass("Part")
local prox = v:FindFirstChild("ProximityPrompt")
if itemPart and prox and itemPart.Transparency < 1 then -- Added check
local itemName = prox.ObjectText or "Unknown Item"
if not v:FindFirstChild("ItemESP") then
local hl = Instance.new("Highlight")
            hl.Name = "ItemESP"
            hl.FillTransparency = 0.7
            hl.FillColor = Color3.fromRGB(0, 255, 0)
            hl.OutlineTransparency = 0
            hl.OutlineColor = Color3.fromRGB(255, 0, 0)
            hl.Adornee = v
            hl.Parent = v
end
if not v:FindFirstChild("ItemESPName") then
local bb = Instance.new("BillboardGui")
            bb.Name = "ItemESPName"
            bb.Adornee = itemPart
            bb.Size = UDim2.new(0, 200, 0, 50)
            bb.StudsOffset = Vector3.new(0, 3, 0)
            bb.AlwaysOnTop = true
            bb.Parent = v
local tl = Instance.new("TextLabel")
            tl.Size = UDim2.new(1, 0, 1, 0)
            tl.BackgroundTransparency = 1
            tl.Text = itemName
            tl.TextColor3 = Color3.fromRGB(255, 255, 255)
            tl.TextSize = 24
            tl.TextStrokeTransparency = 0.5
            tl.Font = Enum.Font.SourceSansBold
            tl.Parent = bb
end
end
end
local function enableItemESP()
for _, v in pairs(game.Workspace.Item_Spawns.Items:GetChildren()) do
        addItemESP(v)
end
    espConnection = game.Workspace.Item_Spawns.Items.ChildAdded:Connect(function(v)
wait(0.1)
        addItemESP(v)
end)
end
local function disableItemESP()
for _, v in pairs(game.Workspace.Item_Spawns.Items:GetChildren()) do
local hl = v:FindFirstChild("ItemESP")
if hl then
            hl:Destroy()
end
local bb = v:FindFirstChild("ItemESPName")
if bb then
            bb:Destroy()
end
end
if espConnection then
        espConnection:Disconnect()
end
end
-- Player ESP (Red and White)
local playerESP = false
local playerESPConnections = {}
local function addPlayerESP(plr)
if plr == player then return end
if not plr.Character then return end
local char = plr.Character
local hl = Instance.new("Highlight")
    hl.Name = "PlayerESP"
    hl.FillTransparency = 0.7
    hl.FillColor = Color3.fromRGB(255, 0, 0) -- Red fill
    hl.OutlineTransparency = 0
    hl.OutlineColor = Color3.fromRGB(255, 255, 255) -- White outline
    hl.Adornee = char
    hl.Parent = char
local bb = Instance.new("BillboardGui")
    bb.Name = "PlayerESPName"
    bb.Adornee = char:FindFirstChild("Head")
    bb.Size = UDim2.new(0, 200, 0, 50)
    bb.StudsOffset = Vector3.new(0, 3, 0)
    bb.AlwaysOnTop = true
    bb.Parent = char
local tl = Instance.new("TextLabel")
    tl.Size = UDim2.new(1, 0, 1, 0)
    tl.BackgroundTransparency = 1
    tl.Text = plr.Name
    tl.TextColor3 = Color3.fromRGB(255, 255, 255)
    tl.TextSize = 24
    tl.TextStrokeTransparency = 0.5
    tl.Font = Enum.Font.SourceSansBold
    tl.Parent = bb
-- Handle character respawn
local conn = plr.CharacterAdded:Connect(function(newChar)
        hl.Adornee = newChar
        bb.Adornee = newChar:WaitForChild("Head")
end)
    table.insert(playerESPConnections, conn)
end
local function enablePlayerESP()
for _, plr in pairs(game.Players:GetPlayers()) do
        addPlayerESP(plr)
end
local addedConn = game.Players.PlayerAdded:Connect(function(plr)
        addPlayerESP(plr)
end)
    table.insert(playerESPConnections, addedConn)
end
local function disablePlayerESP()
for _, plr in pairs(game.Players:GetPlayers()) do
if plr.Character then
local hl = plr.Character:FindFirstChild("PlayerESP")
if hl then
                hl:Destroy()
end
local bb = plr.Character:FindFirstChild("PlayerESPName")
if bb then
                bb:Destroy()
end
end
end
for _, conn in pairs(playerESPConnections) do
        conn:Disconnect()
end
    playerESPConnections = {}
end
-- Item Spawn Notifier
local itemNotifier = false
local notifierConnection
local function enableItemNotifier()
    notifierConnection = game.Workspace.Item_Spawns.Items.ChildAdded:Connect(function(v)
wait(0.1)
local prox = v:FindFirstChild("ProximityPrompt")
if prox then
local itemName = prox.ObjectText or "Unknown Item"
            notify("YBA Script", itemName .. " has spawned!")
end
end)
end
local function disableItemNotifier()
if notifierConnection then
        notifierConnection:Disconnect()
end
end
-- Instant Pick Up (drop-in)
local instantPickup = false
local instantPickupConnection = nil
local defaultHoldDuration = 0.5 -- change if your game uses a different default
local function getItemContainer()
local spawns = workspace:FindFirstChild("Item_Spawns")
if not spawns then return nil end
return spawns:FindFirstChild("Items")
end
local function setPromptsInstant(instant)
local container = getItemContainer()
if not container then return end
for _, v in pairs(container:GetChildren()) do
local prox = v:FindFirstChild("ProximityPrompt")
if prox then
-- set hold duration to 0 for instant (or restore default)
pcall(function() prox.HoldDuration = instant and 0 or defaultHoldDuration end)
end
end
end
local function enableInstantPickup()
    instantPickup = true
    setPromptsInstant(true)
local container = getItemContainer()
if container then
-- handle new spawns: make instant and try to pick immediately
        instantPickupConnection = container.ChildAdded:Connect(function(v)
wait(0.05) -- slight wait so prompt exists
local prox = v:FindFirstChild("ProximityPrompt")
local part = v:FindFirstChildOfClass("MeshPart") or v:FindFirstChildOfClass("Part")
if prox and part.Transparency < 1 then -- Added check
pcall(function() prox.HoldDuration = 0 end)
-- try to fire the prompt (works if your environment has fireproximityprompt helper)
pcall(function() fireproximityprompt(prox, 0) end)
-- fallback: attempt a brief tp to item and back if needed (uncomment if you want)
--[[
                if part and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                    local hrp = player.Character.HumanoidRootPart
                    local oldCFrame = hrp.CFrame
                    hrp.CFrame = part.CFrame
                    wait(0.05)
                    hrp.CFrame = oldCFrame
                end
                --]]
end
end)
end
end
local function disableInstantPickup()
    instantPickup = false
    setPromptsInstant(false)
if instantPickupConnection then
        instantPickupConnection:Disconnect()
        instantPickupConnection = nil
end
end
-- Instant Pick Up
local function instantTravelTo(target)
if not player.Character or not player.Character.HumanoidRootPart then return end
local hrp = player.Character.HumanoidRootPart
local targetPos = typeof(target) == "Vector3" and target or target.Position
    hrp.CFrame = CFrame.new(targetPos + Vector3.new(0, 0.10, 0)) -- slight offset to avoid stuck
end
-- AFK Camera
local afkCameraOn = false
local originalCameraType = nil
local cameraConnection = nil
local cancelGui = nil
local function enableAFKCamera()
if not (normalFarmOn or afkFarmOn) then
        notify("YBA Script", "AFK Camera only works when farming is enabled.")
        afkCameraToggle:Set(false)
return
end
    originalCameraType = workspace.CurrentCamera.CameraType
workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
    cameraConnection = RunService.RenderStepped:Connect(function()
if player.Character and player.Character:FindFirstChild("Head") then
local head = player.Character.Head
local camPos = head.Position + Vector3.new(0, 15, 0) -- Adjust height as needed, 15 studs above
local lookAt = head.Position
workspace.CurrentCamera.CFrame = CFrame.new(camPos, lookAt)
end
end)
-- Cancel UI
    cancelGui = Instance.new("ScreenGui")
    cancelGui.Name = "CancelAFK"
    cancelGui.Parent = player.PlayerGui
    cancelGui.ResetOnSpawn = false
local cancelButton = Instance.new("TextButton")
    cancelButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    cancelButton.BorderSizePixel = 0
    cancelButton.Position = UDim2.new(0.5, -100, 0.9, -50)
    cancelButton.Size = UDim2.new(0, 200, 0, 50)
    cancelButton.Font = Enum.Font.SourceSansBold
    cancelButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    cancelButton.TextSize = 24
    cancelButton.Text = "Cancel AFK Camera"
    cancelButton.Parent = cancelGui
    cancelButton.MouseButton1Click:Connect(function()
        afkCameraToggle:Set(false)
end)
local uicorner = Instance.new("UICorner")
    uicorner.Parent = cancelButton
end
local function disableAFKCamera()
if originalCameraType then
workspace.CurrentCamera.CameraType = originalCameraType
end
if cameraConnection then
        cameraConnection:Disconnect()
end
if cancelGui then
        cancelGui:Destroy()
end
end
player.CharacterAdded:Connect(function(char)
if afkCameraOn then
wait(1)
-- Camera will update in RenderStepped
end
end)
-- Farming Tab
local farmMethod = "Normal"
FarmingTab:Dropdown({
    Flag = "FarmMethod",
    Title = "Farm Method",
    Values = {"Normal", "AFK Farming"},
    Value = "Normal",
    Callback = function(option)
        farmMethod = option
end
})
FarmingTab:Space()
FarmingTab:Dropdown({
    Flag = "FarmItem",
    Title = "Select Item to Farm",
    Values = itemOptions,
    Multi = true,
    Callback = function(selected)
        selectedFarmItems = selected
end
})
FarmingTab:Space()
FarmingTab:Dropdown({
    Flag = "TravelMethod",
    Title = "Travel Method",
    Values = {"Stud", "Tween"},
    Value = "Stud",
    Callback = function(option)
        travelMethod = option
end
})
FarmingTab:Space()
local tpToItemsToggle = FarmingTab:Toggle({
    Flag = "TpToItems",
    Title = "Enable Farming",
    Default = false,
    Callback = function(value)
local method = farmMethod
if value then
            notify("YBA Script", method .. " enabled.")
            startFarming(method)
else
            notify("YBA Script", "Farming disabled.")
            stopFarming()
end
end
})
FarmingTab:Space()
FarmingTab:Section({
    Title = "Gamble",
})
local gambleOn = false
local lastGambleTime = 0
local gambleToggle = FarmingTab:Toggle({
    Flag = "Gamble",
    Title = "Enable",
    Default = false,
    Callback = function(value)
        gambleOn = value
        if value then
            notify("YBA Script", "Auto Gamble enabled.")
        else
            notify("YBA Script", "Auto Gamble disabled.")
        end
    end
})
spawn(function()
    while true do
        wait(0.5)
        if gambleOn then
            pcall(function()
                local hasGold = false
                local goldItem = player.Backpack:FindFirstChild("Gold Coin") or (player.Character and player.Character:FindFirstChild("Gold Coin"))
                if goldItem then
                    hasGold = true
                    if goldItem.Parent == player.Backpack then
                        goldItem.Parent = player.Character
                    end
                end
                local money = player.PlayerStats.Money.Value
                if hasGold and money >= 750 then
                    local remote = player.Character:FindFirstChild("RemoteEvent")
                    if remote then
                        remote:FireServer("DialogueInteracted", {
                            ["DialogueName"] = "Item Machine",
                            ["Speaker"] = "Item Machine"
                        })
                        remote:FireServer("EndDialogue", {
                            ["NPC"] = "Item Machine",
                            ["Option"] = "Option1",
                            ["Dialogue"] = "Dialogue1"
                        })
                        lastGambleTime = tick()
                    end
                    wait(0.5)
                end
            end)
        end
    end
end)
player.Backpack.ChildAdded:Connect(function(item)
    if tick() - lastGambleTime < 2 then
        notify("YBA Script", "Gambled and got: " .. item.Name)
    end
end)
-- Selling Tab
local autoSellMaxToggle = SellingTab:Toggle({
    Flag = "AutoSellMax",
    Title = "Auto Sell on Max",
    Default = false,
    Callback = function(value)
        autoSellMax = value
if autoSellMax then
            notify("YBA Script", "Auto Sell on Max enabled.")
            checkAndSellMax()
else
            notify("YBA Script", "Auto Sell on Max disabled.")
end
end
})
SellingTab:Space()
SellingTab:Dropdown({
    Flag = "AutoSellItems",
    Title = "Auto Sell Items (on Pickup)",
    Values = itemOptions,
    Multi = true,
    Callback = function(selected)
        selectedAutoSellItems = selected
end
})
SellingTab:Space()
local autoSellSelectedToggle = SellingTab:Toggle({
    Flag = "AutoSellSelected",
    Title = "Auto Sell Selected on Pickup",
    Default = false,
    Callback = function(value)
        autoSellSelected = value
if autoSellSelected then
            notify("YBA Script", "Auto Sell Selected enabled.")
else
            notify("YBA Script", "Auto Sell Selected disabled.")
end
end
})
SellingTab:Space()
SellingTab:Dropdown({
    Flag = "SellAllItems",
    Title = "Select Items to Sell All Now",
    Values = itemOptions,
    Multi = true,
    Callback = function(selected)
        selectedSellAllItems = selected
end
})
SellingTab:Space()
SellingTab:Button({
    Title = "Sell All Selected Now",
    Callback = function()
        sellAllSelected(selectedSellAllItems)
end
})
SellingTab:Space()
SellingTab:Button({
    Title = "Sell All Worthless Items",
    Callback = function()
        sellAllWorthless()
end
})
SellingTab:Space()
SellingTab:Button({
    Title = "Sell Inventory",
    Callback = function()
        sellInventory()
end
})
-- Visual Tab
local itemESPToggle = VisualTab:Toggle({
    Flag = "ItemESP",
    Title = "Item ESP",
    Default = false,
    Callback = function(value)
        itemESP = value
if itemESP then
            notify("YBA Script", "Item ESP enabled.")
            enableItemESP()
else
            notify("YBA Script", "Item ESP disabled.")
            disableItemESP()
end
end
})
VisualTab:Space()
local playerESPToggle = VisualTab:Toggle({
    Flag = "PlayerESP",
    Title = "Player ESP",
    Default = false,
    Callback = function(value)
        playerESP = value
if playerESP then
            notify("YBA Script", "Player ESP enabled.")
            enablePlayerESP()
else
            notify("YBA Script", "Player ESP disabled.")
            disablePlayerESP()
end
end
})
VisualTab:Space()
local itemNotifierToggle = VisualTab:Toggle({
    Flag = "ItemNotifier",
    Title = "Item Spawn Notifier",
    Default = false,
    Callback = function(value)
        itemNotifier = value
if itemNotifier then
            notify("YBA Script", "Item Spawn Notifier enabled.")
            enableItemNotifier()
else
            notify("YBA Script", "Item Spawn Notifier disabled.")
            disableItemNotifier()
end
end
})
VisualTab:Space()
local showTopBarToggle = VisualTab:Toggle({
    Flag = "ShowTopBar",
    Title = "Show Top Bar",
    Default = true,
    Callback = function(value)
        topGui.Enabled = value
end
})
-- Misc Tab
local antiAFKToggle = MiscTab:Toggle({
    Flag = "AntiAFK",
    Title = "Anti-AFK",
    Default = false,
    Callback = function(value)
if value then
            notify("YBA Script", "Anti-AFK enabled.")
spawn(function()
while value do
wait(300)
local vu = game:GetService("VirtualUser")
                    vu:CaptureController()
                    vu:ClickButton2(Vector2.new())
end
end)
else
            notify("YBA Script", "Anti-AFK disabled.")
end
end
})
MiscTab:Space()
local originalLighting = {
    Brightness = game.Lighting.Brightness,
    ClockTime = game.Lighting.ClockTime,
    FogEnd = game.Lighting.FogEnd,
    GlobalShadows = game.Lighting.GlobalShadows,
    Ambient = game.Lighting.Ambient
}
local fpsBoosterToggle = MiscTab:Toggle({
    Flag = "FpsBooster",
    Title = "FPS Booster",
    Default = false,
    Callback = function(value)
if value then
            notify("YBA Script", "FPS Booster enabled.")
local lighting = game.Lighting
            lighting.Brightness = 2
            lighting.ClockTime = 14
            lighting.FogEnd = 100000
            lighting.GlobalShadows = false
            lighting.Ambient = Color3.fromRGB(255, 255, 255)
-- Remove highlights (assuming disabling all Highlight instances in workspace)
for _, obj in pairs(game.Workspace:GetDescendants()) do
if obj:IsA("Highlight") then
                    obj.Enabled = false
end
end
-- Additional shadow/highlight removal if needed (e.g., disable post-processing)
if game.Lighting:FindFirstChild("Bloom") then
game.Lighting.Bloom.Enabled = false
end
if game.Lighting:FindFirstChild("SunRays") then
game.Lighting.SunRays.Enabled = false
end
if game.Lighting:FindFirstChild("DepthOfField") then
game.Lighting.DepthOfField.Enabled = false
end
else
            notify("YBA Script", "FPS Booster disabled.")
local lighting = game.Lighting
            lighting.Brightness = originalLighting.Brightness
            lighting.ClockTime = originalLighting.ClockTime
            lighting.FogEnd = originalLighting.FogEnd
            lighting.GlobalShadows = originalLighting.GlobalShadows
            lighting.Ambient = originalLighting.Ambient
-- Re-enable highlights
for _, obj in pairs(game.Workspace:GetDescendants()) do
if obj:IsA("Highlight") then
                    obj.Enabled = true
end
end
if game.Lighting:FindFirstChild("Bloom") then
game.Lighting.Bloom.Enabled = true
end
if game.Lighting:FindFirstChild("SunRays") then
game.Lighting.SunRays.Enabled = true
end
if game.Lighting:FindFirstChild("DepthOfField") then
game.Lighting.DepthOfField.Enabled = true
end
end
end
})
MiscTab:Space()
local instantPickupToggle = MiscTab:Toggle({
    Flag = "InstantPickup",
    Title = "Instant Pick Up",
    Default = false,
    Callback = function(value)
if value then
            enableInstantPickup()
            notify("YBA Script", "Instant Pick Up enabled.")
else
            disableInstantPickup()
            notify("YBA Script", "Instant Pick Up disabled.")
end
end
})
MiscTab:Space()
local afkCameraToggle = MiscTab:Toggle({
    Flag = "AFKCamera",
    Title = "AFK Camera",
    Default = false,
    Callback = function(value)
        afkCameraOn = value
if value then
            notify("YBA Script", "AFK Camera enabled.")
            enableAFKCamera()
else
            notify("YBA Script", "AFK Camera disabled.")
            disableAFKCamera()
end
end
})
-- Adjust Tab
local lastSpeedNotify = 0
local farmingSpeedSlider = AdjustTab:Slider({
    Flag = "FarmingSpeed",
    Title = "Farming Speed",
    Step = 1,
    Value = {
        Min = 1,
        Max = 100,
        Default = 1,
},
    Callback = function(value)
        speedValue = value
        tpDelay = originalTpDelay / value
if os.clock() - lastSpeedNotify > 1 then
            notify("YBA Script", "Farming Speed adjusted to " .. value .. ".")
            lastSpeedNotify = os.clock()
end
end
})
AdjustTab:Space()
AdjustTab:Button({
    Title = "Reset",
    Callback = function()
        tpDelay = originalTpDelay
        farmingSpeedSlider:Set(1)
        notify("YBA Script", "Farming Speed reset to default.")
end
})
-- Level Farm Features
local quests = {
    ["Level 1"] = {
        npc = "Officer Sam",
        dialogue = {["NPC"] = "Officer Sam", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Thug",
        amount = 5
    },
    ["Level 10"] = {
        npc = "Deputy Bertrude",
        dialogue = {["NPC"] = "Deputy Bertrude", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Corrupt Police",
        amount = 5
    },
    ["Level 15"] = {
        npc = "Abbacchio's Partner",
        dialogue = {["NPC"] = "Abbacchio's Partner", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Alpha Thug",
        amount = 5
    },
    ["Level 25"] = {
        npc = "Antonio Zeppeli",
        dialogue = {["NPC"] = "Antonio Zeppeli", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Zombie",
        amount = 10
    },
    ["Level 30"] = {
        npc = "Doppio",
        dialogue = {["NPC"] = "Doppio", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Vampire",
        amount = 10
    },
    ["Level 35"] = {
        npc = "Dio",
        dialogue = {["NPC"] = "Dio", ["Option"] = "Option1", ["Dialogue"] = "Dialogue1"},
        enemy = "Vampire Minion",
        amount = 10
    },
}
local selectedLevel = "Level 1"
local distance = 3
local levelFarmOn = false
local levelCoroutine = nil
local function findModelByName(name)
    local npcsFolder = game.Workspace:FindFirstChild("NPCs")
    if npcsFolder then
        local npc = npcsFolder:FindFirstChild(name)
        if npc and npc:IsA("Model") then
            return npc
        end
    end
    for _, v in pairs(game.Workspace:GetDescendants()) do
        if v:IsA("Model") and v.Name == name then
            return v
        end
    end
    return nil
end
local function findNearestEnemy(enemyType)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return nil end
    local hrp = player.Character.HumanoidRootPart
    local minDist = math.huge
    local target = nil
    for _, mob in pairs(game.Workspace:GetDescendants()) do
        if mob:IsA("Model") and mob.Name == enemyType and mob:FindFirstChild("Humanoid") and mob.Humanoid.Health > 0 and mob:FindFirstChild("HumanoidRootPart") then
            local dist = (mob.HumanoidRootPart.Position - hrp.Position).Magnitude
            if dist < minDist then
                minDist = dist
                target = mob
            end
        end
    end
    return target
end
local function levelFarm()
    enableNoclip()
    while levelFarmOn do
        if not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0 then
            wait(1)
            continue
        end
        local quest = quests[selectedLevel]
        local npc = quest.npc
        local npcModel = findModelByName(npc)
        if not npcModel or not npcModel:FindFirstChild("HumanoidRootPart") then
            notify("YBA Script", "NPC not found: " .. npc)
            levelFarmOn = false
            break
        end
        local npcHRP = npcModel.HumanoidRootPart
        -- Accept quest
        travelTo(npcHRP.Position)
        wait(0.5)
        local remote = player.Character:FindFirstChild("RemoteEvent")
        if not remote then
            notify("YBA Script", "Remote not found")
            levelFarmOn = false
            break
        end
        remote:FireServer("DialogueInteracted", {["DialogueName"] = npc, ["Speaker"] = npc})
        wait(0.1)
        remote:FireServer("EndDialogue", quest.dialogue)
        wait(0.5)
        -- Kill enemies
        for i = 1, quest.amount do
            local enemy = nil
            while not enemy and levelFarmOn do
                enemy = findNearestEnemy(quest.enemy)
                wait(1)
            end
            if not levelFarmOn then break end
            local enemyHRP = enemy.HumanoidRootPart
            travelTo(enemyHRP.Position - enemyHRP.CFrame.LookVector * distance)
            wait(0.5)
            local connection
            connection = RunService.Heartbeat:Connect(function()
                if not enemy or not enemy:FindFirstChild("Humanoid") or enemy.Humanoid.Health <= 0 or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
                    if connection then connection:Disconnect() end
                    return
                end
                local pos = enemyHRP.Position - enemyHRP.CFrame.LookVector * distance
                player.Character.HumanoidRootPart.CFrame = CFrame.lookAt(pos, enemyHRP.Position)
            end)
            local punchTime = 0
            while enemy and enemy:FindFirstChild("Humanoid") and enemy.Humanoid.Health > 0 and levelFarmOn do
                if tick() - punchTime > 0.08 then
                    remote:FireServer("Punch")
                    punchTime = tick()
                end
                wait(0.01)
            end
            if connection then connection:Disconnect() end
        end
        if not levelFarmOn then break end
        -- Complete quest
        travelTo(npcHRP.Position)
        wait(0.5)
        remote:FireServer("DialogueInteracted", {["DialogueName"] = npc, ["Speaker"] = npc})
        wait(0.1)
        remote:FireServer("EndDialogue", quest.dialogue)
        wait(0.5)
    end
    disableNoclip()
end
LevelFarmTab:Dropdown({
    Flag = "SelectLevel",
    Title = "Select Level",
    Values = {"Level 1", "Level 10", "Level 15", "Level 25", "Level 30", "Level 35"},
    Value = "Level 1",
    Callback = function(option)
        selectedLevel = option
    end
})
LevelFarmTab:Space()
LevelFarmTab:Slider({
    Flag = "EnemyDistance",
    Title = "Distance from Enemy",
    Step = 0.5,
    Value = {
        Min = 1,
        Max = 10,
        Default = 3,
    },
    Callback = function(value)
        distance = value
    end
})
LevelFarmTab:Space()
local levelFarmToggle = LevelFarmTab:Toggle({
    Flag = "LevelFarm",
    Title = "Enable Level Farm",
    Default = false,
    Callback = function(value)
        if value then
            notify("YBA Script", "This feature is not yet available.")
            levelFarmToggle:Set(false)
        end
    end
})
LevelFarmTab:Section({
    Title = "This feature is not yet available.",
    TextSize = 18,
    TextTransparency = .35,
    FontWeight = Enum.FontWeight.Medium,
})
player.CharacterAdded:Connect(function(char)
    if levelFarmOn then
        wait(2)
        enableNoclip()
        levelCoroutine = coroutine.wrap(levelFarm)()
    end
end)
-- Trolling Tab (Stand Stick)
local targetName = ""
TrollingTab:Input({
    Flag = "TargetName",
    Title = "Enter Player/Mob Name",
    Callback = function(value)
        targetName = value
    end
})
TrollingTab:Space()
local stickerToggle = TrollingTab:Toggle({
    Flag = "Sticker",
    Title = "Sticker",
    Default = false,
    Callback = function(value)
        stickerEnabled = value
        if value then
            notify("YBA Script", "Sticker enabled for: ".. (targetName ~= "" and targetName or "<empty>"))
        else
            notify("YBA Script", "Sticker disabled")
            for stand, _ in pairs(activeAligns) do cleanupAlignForStand(stand) end
            local stand = getStand()
            if stand then
                local hrp = stand:FindFirstChild("HumanoidRootPart")
                local myhrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                if hrp and myhrp then
                    local desiredCFrame = CFrame.new(myhrp.Position - myhrp.CFrame.LookVector * BACK_DISTANCE + Vector3.new(0, BACK_HEIGHT, 0)) * myhrp.CFrame.Rotation
                    hrp.Anchored = true
                    hrp.CFrame = desiredCFrame
                    hrp.Velocity = Vector3.new(0,0,0)
                    hrp.AssemblyLinearVelocity = Vector3.new(0,0,0)
                    hrp.AssemblyAngularVelocity = Vector3.new(0,0,0)
                    wait(0.1)
                    hrp.Anchored = false
                    for _, c in ipairs(hrp:GetChildren()) do
                        if c:IsA("BodyPosition") or c:IsA("BodyGyro") or c:IsA("AlignPosition") or c:IsA("AlignOrientation") then
                            c:Destroy()
                        end
                    end
                end
            end
        end
    end
})
TrollingTab:Space()
local viewEnabled = false
local viewing = false
local prevCameraSubject = nil
local prevCameraType = nil
local viewingStand = nil
local orbitConnections = {}
local renderConn = nil
local camera = game.Workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local function enableOrbitView()
    local stand = getStand()
    if not stand then
        notify("View Stand", "Equip stand to view.")
        return
    end
    local hrp = stand:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    prevCameraSubject = camera.CameraSubject
    prevCameraType = camera.CameraType
    camera.CameraType = Enum.CameraType.Scriptable
    local ORBIT_SENSITIVITY = 0.0035
    local ORBIT_RADIUS_MIN = 2
    local ORBIT_RADIUS_MAX = 60
    local orbit = {
        yaw = 0,
        pitch = 0,
        radius = 8,
        minRadius = ORBIT_RADIUS_MIN,
        maxRadius = ORBIT_RADIUS_MAX,
        sensitivity = ORBIT_SENSITIVITY,
        pitchMin = -math.pi / 2 + 0.1,
        pitchMax = math.pi / 2 - 0.1,
        dragging = false,
    }
    local standPos = hrp.Position
    local camCF = camera.CFrame
    local toStand = camCF.Position - standPos
    orbit.radius = math.clamp(toStand.Magnitude, orbit.minRadius, orbit.maxRadius)
    local dir = toStand.Unit
    orbit.pitch = -math.asin(math.clamp(dir.Y, -1, 1))
    orbit.yaw = math.atan2(dir.X, dir.Z)
    local inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
        if processed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            orbit.dragging = true
            UserInputService.MouseIconEnabled = false
        end
    end)
    table.insert(orbitConnections, inputBeganConn)
    local inputEndedConn = UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton2 then
            orbit.dragging = false
            UserInputService.MouseIconEnabled = true
        end
    end)
    table.insert(orbitConnections, inputEndedConn)
    local inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
        if input.UserInputType == Enum.UserInputType.MouseMovement and orbit.dragging then
            orbit.yaw = orbit.yaw - input.Delta.X * orbit.sensitivity
            orbit.pitch = math.clamp(orbit.pitch - input.Delta.Y * orbit.sensitivity, orbit.pitchMin, orbit.pitchMax)
        elseif input.UserInputType == Enum.UserInputType.MouseWheel then
            orbit.radius = math.clamp(orbit.radius - input.Position.Z, orbit.minRadius, orbit.maxRadius)
        end
    end)
    table.insert(orbitConnections, inputChangedConn)
    renderConn = RunService.RenderStepped:Connect(function()
        if not stand or not stand.Parent then
            disableOrbitView()
            return
        end
        local root = stand:FindFirstChild("HumanoidRootPart")
        if not root then return end
        local standPos = root.Position
        local rot = CFrame.Angles(orbit.pitch, orbit.yaw, 0)
        local offset = rot:VectorToWorldSpace(Vector3.new(0, 0, orbit.radius))
        local camPos = standPos + offset
        camera.CFrame = CFrame.new(camPos, standPos)
    end)
    viewing = true
    viewingStand = stand
    notify("View Stand", "Viewing your stand with orbit camera.")
end
local function disableOrbitView()
    viewing = false
    viewingStand = nil
    if prevCameraType then
        camera.CameraType = prevCameraType
    end
    if prevCameraSubject then
        camera.CameraSubject = prevCameraSubject
    end
    UserInputService.MouseIconEnabled = true
    for _, conn in ipairs(orbitConnections) do
        conn:Disconnect()
    end
    orbitConnections = {}
    if renderConn then
        renderConn:Disconnect()
        renderConn = nil
    end
    notify("View Stand", "Stand view disabled. Camera restored.")
end
local viewToggle = TrollingTab:Toggle({
    Flag = "ViewStand",
    Title = "View Stand",
    Default = false,
    Callback = function(value)
        viewEnabled = value
        if value then
            local stand = getStand()
            if stand and stand:FindFirstChild("HumanoidRootPart") then
                enableOrbitView()
            else
                notify("View Stand", "Will view when stand equipped.")
            end
        else
            disableOrbitView()
        end
    end
})
-- Settings Tab (Config Usage from example)
local ConfigTab = SettingsTab
local ConfigManager = Window.ConfigManager
local ConfigName = "default"
local ConfigNameInput = ConfigTab:Input({
    Flag = "ConfigName",
    Title = "Config Name",
    Icon = "file-cog",
    Callback = function(value)
        ConfigName = value
end
})
local AllConfigs = ConfigManager:AllConfigs()
local DefaultValue = table.find(AllConfigs, ConfigName) and ConfigName or nil
ConfigTab:Dropdown({
    Title = "All Configs",
    Desc = "Select existing configs",
    Values = AllConfigs,
    Value = DefaultValue,
    Callback = function(value)
        ConfigName = value
        ConfigNameInput:Set(value)
end
})
ConfigTab:Space()
ConfigTab:Button({
    Title = "Save Config",
    Icon = "",
    Justify = "Center",
    Callback = function()
        Window.CurrentConfig = ConfigManager:CreateConfig(ConfigName)
if Window.CurrentConfig:Save() then
            WindUI:Notify({
                Title = "Config Saved",
                Desc = "Config '" .. ConfigName .. "' saved",
                Icon = "check",
})
end
end
})
ConfigTab:Space()
ConfigTab:Button({
    Title = "Load Config",
    Icon = "",
    Justify = "Center",
    Callback = function()
        Window.CurrentConfig = ConfigManager:CreateConfig(ConfigName)
if Window.CurrentConfig:Load() then
            WindUI:Notify({
                Title = "Config Loaded",
                Desc = "Config '" .. ConfigName .. "' loaded",
                Icon = "refresh-cw",
})
end
end
})
ConfigTab:Space()
local autoLoadToggle = ConfigTab:Toggle({
    Flag = "AutoLoad",
    Title = "Auto Load Script",
    Default = false
})
ConfigTab:Space()
-- Theme Changer (assuming WindUI has themes, placeholder)
ConfigTab:Dropdown({
    Title = "Theme Changer",
    Values = {"Dark", "Light", "Custom"}, -- Adjust based on WindUI themes
    Callback = function(theme)
-- Placeholder: Apply theme
        notify("YBA Script", "Theme changed to " .. theme)
-- WindUI:SetTheme(theme) if available
end
})
ConfigTab:Space()
-- Keybind Changer
ConfigTab:Keybind({
    Flag = "ToggleKey",
    Title = "Keybind Changer",
    Default = Enum.KeyCode.K,
    Callback = function(key)
        Window:SetToggleKey(key)
        notify("YBA Script", "Toggle key changed to " .. key.Name)
end
})
-- Load default config
local defaultConfig = ConfigManager:CreateConfig("default")
defaultConfig:Load()
-- Ensure all features are off by default
tpToItemsToggle:Set(false)
autoSellMaxToggle:Set(false)
autoSellSelectedToggle:Set(false)
itemESPToggle:Set(false)
playerESPToggle:Set(false)
itemNotifierToggle:Set(false)
showTopBarToggle:Set(false)
antiAFKToggle:Set(false)
fpsBoosterToggle:Set(false)
instantPickupToggle:Set(false)
afkCameraToggle:Set(false)
autoLoadToggle:Set(false)
notify("YBA Script", "Script loaded successfully.")
-- Auto Rejoin on Kick/Disconnect
local TeleportService = game:GetService("TeleportService")
spawn(function()
while true do
wait(1)
pcall(function()
local coreGui = game:GetService("CoreGui")
local prompt = coreGui:FindFirstChild("RobloxPromptGui")
if prompt then
local overlay = prompt:FindFirstChild("promptOverlay")
if overlay then
local errorPrompt = overlay:FindFirstChild("ErrorPrompt")
if errorPrompt and errorPrompt.Visible then
local titleFrame = errorPrompt:FindFirstChild("TitleFrame")
if titleFrame then
local errorTitle = titleFrame:FindFirstChild("ErrorTitle")
if errorTitle and (string.lower(errorTitle.Text):find("disconnect") or string.lower(errorTitle.Text):find("kicked")) then
                                notify("YBA Script", "Detected kick/disconnect. Rejoining the server...")
-- If your executor supports queue_on_teleport (e.g., Synapse, Krnl), you can queue the script reload here.
-- Example: if queue_on_teleport then queue_on_teleport("loadstring(game:HttpGet('YOUR_SCRIPT_URL'))()") end
-- Assuming your executor auto-executes the script on join, it will reload automatically.
                                TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId)
end
                        end
                    end
                end
            end
        end)
    end
end)
-- Integrated Trolling Feature: Stand Sticker (functional parts without custom UI)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local workspace = game:GetService("Workspace")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
-- CONFIG
local BACK_DISTANCE = 2 -- studs behind target
local BACK_HEIGHT = 0.5 -- height above target HRP
local ALIGN_RESPONSIVENESS = 250
local ALIGN_MAX_FORCE = 1e7
local CHECK_SCAN_INTERVAL = 1.0
local SMOOTH_FALLBACK_ALPHA = 0.85
-- New: max distance allowed between you and the target to operate sticker
local MAX_OPERATE_DISTANCE = 60 -- studs. If you're beyond this from the target, notify.
-- Hysteresis to avoid rapid toggling (must come this much inside before notifications reset)
local TOO_FAR_HYSTERESIS = 3 -- studs
-- NPC + Player scanning (low-lag cache)
local scanTimer = 0
local modelCache = {} -- array of models (NPCs and player characters)
local function isCharacterModel(m)
    if not m or not m:IsA("Model") then return false end
    return m:FindFirstChild("Humanoid") and m:FindFirstChild("HumanoidRootPart")
end
local function rebuildModelCache()
    modelCache = {}
    -- NPCs / world models in workspace
    for _, child in ipairs(workspace:GetChildren()) do
        if isCharacterModel(child) then
            table.insert(modelCache, child)
        else
            for _, c2 in ipairs(child:GetChildren()) do
                if isCharacterModel(c2) then table.insert(modelCache, c2) end
            end
        end
    end
    -- players' characters (ensure they're present)
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= player and pl.Character and isCharacterModel(pl.Character) then
            table.insert(modelCache, pl.Character)
        end
    end
end
rebuildModelCache()
workspace.ChildAdded:Connect(function(c)
    if isCharacterModel(c) then table.insert(modelCache, c) else
        for _, c2 in ipairs(c:GetChildren()) do if isCharacterModel(c2) then table.insert(modelCache, c2) end end
    end
end)
workspace.ChildRemoved:Connect(function(c)
    for i = #modelCache, 1, -1 do if modelCache[i] == c then table.remove(modelCache, i) end end
end)
Players.PlayerAdded:Connect(function(pl)
    pl.CharacterAdded:Connect(function(ch)
        if isCharacterModel(ch) then table.insert(modelCache, ch) end
    end)
end)
Players.PlayerRemoving:Connect(function(pl)
    if pl.Character then
        for i = #modelCache, 1, -1 do if modelCache[i] == pl.Character then table.remove(modelCache, i) end end
    end
end)
-- Find closest target (player or NPC) by name or displayName; ignores local player
local function findClosestByName(name)
    if not name or name == "" then return nil end
    local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not root then return nil end
    local lower = name:lower()
    local closest, minD = nil, math.huge
    -- check players first (so exact player names are preferred)
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= player and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local match = false
            if pl.Name:lower():find(lower) then match = true end
            if pl.DisplayName and pl.DisplayName:lower():find(lower) then match = true end
            if match then
                local hrp = pl.Character:FindFirstChild("HumanoidRootPart")
                local hum = pl.Character:FindFirstChild("Humanoid")
                if hrp and hum and hum.Health > 0 then
                    local d = (hrp.Position - root.Position).Magnitude
                    if d < minD then minD, closest = d, pl.Character end
                end
            end
        end
    end
    -- scan model cache for NPCs and other models
    for _, model in ipairs(modelCache) do
        if model and model.Parent and model ~= player.Character then
            if model.Name:lower():find(lower) then
                local hrp = model:FindFirstChild("HumanoidRootPart")
                local hum = model:FindFirstChild("Humanoid")
                if hrp and hum and hum.Health > 0 then
                    local d = (hrp.Position - root.Position).Magnitude
                    if d < minD then minD, closest = d, model end
                end
            end
        end
    end
    return closest
end
-- Stand finder: finds a Model in player's character (not the player's character itself)
local function getStand()
    local ch = player.Character
    if not ch then return nil end
    for _, child in ipairs(ch:GetChildren()) do
        if child:IsA("Model") and child:FindFirstChild("HumanoidRootPart") and child ~= ch then
            return child
        end
    end
    return nil
end
-- Align management
local activeAligns = {}
local currentTargetForStand = {}
local function cleanupAlignForStand(stand)
    if not stand then return end
    local hrp = stand:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    for _, c in ipairs(hrp:GetChildren()) do
        if tostring(c.Name):match("^Stick_") then
            c:Destroy()
        end
    end
    if activeAligns[stand] and activeAligns[stand].attB then
        activeAligns[stand].attB:Destroy()
    end
    activeAligns[stand] = nil
    currentTargetForStand[stand] = nil
end
local function createAlignsFor(stand, targetHRP)
    if not stand or not targetHRP then return nil end
    cleanupAlignForStand(stand)
    local hrp = stand:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end
    local attA = Instance.new("Attachment")
    attA.Name = "Stick_AttA"
    attA.Parent = hrp
    attA.Position = Vector3.new(0,0,0)
    local attB = Instance.new("Attachment")
    attB.Name = "Stick_AttB"
    attB.Parent = targetHRP
    attB.Position = Vector3.new(0, BACK_HEIGHT, -BACK_DISTANCE) -- initial
    local alignPos = Instance.new("AlignPosition")
    alignPos.Name = "Stick_AlignPos"
    alignPos.Attachment0 = attA
    alignPos.Attachment1 = attB
    alignPos.MaxForce = ALIGN_MAX_FORCE
    alignPos.Responsiveness = ALIGN_RESPONSIVENESS
    alignPos.RigidityEnabled = true
    alignPos.Parent = hrp
    local alignOri = Instance.new("AlignOrientation")
    alignOri.Name = "Stick_AlignOri"
    alignOri.Attachment0 = attA
    alignOri.Attachment1 = attB
    alignOri.MaxTorque = ALIGN_MAX_FORCE
    alignOri.Responsiveness = ALIGN_RESPONSIVENESS
    alignOri.Parent = hrp
    activeAligns[stand] = {attA = attA, attB = attB, alignPos = alignPos, alignOri = alignOri}
    currentTargetForStand[stand] = targetHRP
    return activeAligns[stand]
end
local function smoothFallback(stand, targetHRP)
    local hrp = stand and stand:FindFirstChild("HumanoidRootPart")
    if not hrp or not targetHRP then return end
    local desiredPos = targetHRP.Position - targetHRP.CFrame.LookVector * BACK_DISTANCE + Vector3.new(0, BACK_HEIGHT, 0)
    -- rotate to roughly match target facing (so stand sits naturally on back)
    local look = -Vector3.new(targetHRP.CFrame.LookVector.X, 0, targetHRP.CFrame.LookVector.Z)
    local yaw = math.atan2(look.X, look.Z)
    local desiredCFrame = CFrame.new(desiredPos) * CFrame.Angles(0, yaw, 0)
    hrp.CFrame = hrp.CFrame:Lerp(desiredCFrame, SMOOTH_FALLBACK_ALPHA)
end
-- Notifier state: only notify once when entering "too far" state
local tooFarNotified = false
local lastStandNotify = 0
-- Main heartbeat loop
RunService.Heartbeat:Connect(function(dt)
    -- periodic scan rebuild
    scanTimer = scanTimer + dt
    if scanTimer >= CHECK_SCAN_INTERVAL then
        rebuildModelCache()
        scanTimer = 0
    end
    -- camera upkeep: if viewing but stand lost, restore camera
    if viewing then
        if not viewingStand or not viewingStand.Parent or not viewingStand:FindFirstChild("HumanoidRootPart") then
            disableOrbitView()
        end
    end
    if viewEnabled and not viewing then
        local stand = getStand()
        if stand and stand:FindFirstChild("HumanoidRootPart") then
            enableOrbitView()
        end
    end
    if not stickerEnabled then return end
    local name = targetName
    if not name or name == "" then return end
    local stand = getStand()
    if not stand then
        if tick() - lastStandNotify > 5 then
            notify("Sticker", "Equip your stand to use sticker.")
            lastStandNotify = tick()
        end
        return
    end
    local target = findClosestByName(name)
    if not target then
        -- no target nearby
        -- reset notified flag when no target so notification can trigger next time a target appears and you're too far
        tooFarNotified = false
        cleanupAlignForStand(stand)
        return
    end
    local targetHRP = target:FindFirstChild("HumanoidRootPart")
    if (not targetHRP) or (target:FindFirstChild("Humanoid") and target.Humanoid.Health <= 0) then
        cleanupAlignForStand(stand)
        tooFarNotified = false
        return
    end
    -- distance check between local player and the target: notify if too far (only once on enter)
    local myRoot = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    local distToTarget = (myRoot.Position - targetHRP.Position).Magnitude
    if distToTarget > MAX_OPERATE_DISTANCE then
        if not tooFarNotified then
            notify("Sticker Warning", "You are too far from the target! Move closer to avoid issues.")
            tooFarNotified = true
        end
        -- optionally cleanup aligns so stand doesn't try to attach while too far
        cleanupAlignForStand(stand)
        return
    else
        -- reset notification when comfortably inside range (use hysteresis)
        if distToTarget <= (MAX_OPERATE_DISTANCE - TOO_FAR_HYSTERESIS) then
            tooFarNotified = false
        end
    end
    -- Ensure align exists for this stand+target, recreate if target changed
    if currentTargetForStand[stand] ~= targetHRP then
        local ok, res = pcall(createAlignsFor, stand, targetHRP)
        if not ok or not res then
            -- Align creation failed (maybe blocked) -> fallback mode
            cleanupAlignForStand(stand)
        end
    end
    -- If align present, compute world-space back position and write local pos into attachment
    local alignData = activeAligns[stand]
    if alignData and alignData.attB and alignData.attB.Parent == targetHRP then
        -- desired world position behind target using LookVector
        local desiredWorldPos = targetHRP.Position - targetHRP.CFrame.LookVector * BACK_DISTANCE + Vector3.new(0, BACK_HEIGHT, 0)
        -- convert to target local space and set attachment position
        local localPos = targetHRP.CFrame:PointToObjectSpace(desiredWorldPos)
        alignData.attB.Position = localPos
    else
        -- fallback: smooth CFrame lerp
        pcall(smoothFallback, stand, targetHRP)
    end
end)
-- Cleanup on character removing / script disable
player.CharacterRemoving:Connect(function()
    stickerEnabled = false
    for s,_ in pairs(activeAligns) do cleanupAlignForStand(s) end
    if viewing then disableOrbitView() end
    tooFarNotified = false
end)

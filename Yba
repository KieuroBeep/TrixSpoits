-- Auto-run loader for YBA (PlaceId 2809202155)
-- Paste this into your executor and run once.

local TARGET_PLACE = 2809202155
local REMOTE_URL = "https://raw.githubusercontent.com/KieuroBeep/TrixSpoits/refs/heads/main/Yba-Rawlua"

-- Use getgenv if available to persist flags across script instances/executor states
local env = (type(getgenv) == "function" and getgenv()) or _G

-- Make sure we only queue/execute once per session unless we leave and come back
env.__YBA_AUTO_LOADER = env.__YBA_AUTO_LOADER or {
    queued = false,
    running = false,
    lastPlace = nil
}

local loaderState = env.__YBA_AUTO_LOADER

-- safe wrapper to queue code for execution after teleport (supports many exploits)
local function safe_queue_on_teleport(code)
    local ok, err
    if type(syn) == "table" and syn.queue_on_teleport then
        ok, err = pcall(function() syn.queue_on_teleport(code) end)
        if ok then return true end
    end
    if type(queue_on_teleport) == "function" then
        ok, err = pcall(function() queue_on_teleport(code) end)
        if ok then return true end
    end
    if type(fluxus) == "table" and fluxus.queue_on_teleport then
        ok, err = pcall(function() fluxus.queue_on_teleport(code) end)
        if ok then return true end
    end
    if type(krnl) == "table" and krnl.queue_on_teleport then
        ok, err = pcall(function() krnl.queue_on_teleport(code) end)
        if ok then return true end
    end
    -- Add other executor APIs here if you know them
    return false, err
end

-- build code string that will re-run this exact loader on teleport
local function build_teleport_payload()
    -- we intentionally reference the same URL so the remote script will be fetched
    -- when the teleport happens (keeps it fresh).
    local payload = ([[loadstring(game:HttpGet("%s"))()]]):format(REMOTE_URL)
    -- wrap the payload in a pcall to avoid crashes on load
    return ("pcall(function() %s end)"):format(payload)
end

-- Execute remote script now (with debounce)
local function execute_remote()
    if loaderState.running then return end
    loaderState.running = true

    local ok, err = pcall(function()
        local source = game:HttpGet(REMOTE_URL)
        assert(source and #source > 0, "empty source")
        local fn, loadErr = loadstring(source)
        assert(fn, loadErr or "loadstring failed")
        fn()
    end)

    if not ok then
        warn("[YBA Auto Loader] failed to execute remote script:", err)
        -- allow retries later if remote failed
        loaderState.running = false
        return false, err
    end

    return true
end

-- Ensure we queue the remote loader on teleport so it runs automatically after teleports
local function ensure_queued()
    if loaderState.queued then return end
    local payload = build_teleport_payload()
    local ok, err = safe_queue_on_teleport(payload)
    if ok then
        loaderState.queued = true
        -- it's helpful to also queue a tiny loader that re-initializes this persistence logic if supported
        -- but the above payload is the critical piece: it runs the remote script after teleport.
    else
        -- some executors don't support queue_on_teleport â€” that's ok, the loop below will still try to load when you join the correct place
        warn("[YBA Auto Loader] queue_on_teleport not available or failed:", tostring(err))
    end
end

-- Main watcher loop: checks place id and executes when in the target place.
-- Uses RunService so it's lightweight. If runtime is killed by a teleport/leave, queue_on_teleport is the fallback.
local RunService = game:GetService("RunService")
local CHECK_INTERVAL = 1 -- seconds

-- initial attempt: if already in target, execute immediately
pcall(function()
    if game.PlaceId == TARGET_PLACE then
        execute_remote()
    end
end)

-- try to queue on teleport once at start
pcall(ensure_queued)

-- periodic watcher (will run as long as the executor Lua state remains alive)
spawn(function()
    while true do
        local success, err = pcall(function()
            local currentPlace = game.PlaceId
            if loaderState.lastPlace ~= currentPlace then
                loaderState.lastPlace = currentPlace
                -- if we've moved into the target place, attempt execution
                if currentPlace == TARGET_PLACE then
                    -- make sure we queue again for future teleports
                    pcall(ensure_queued)
                    pcall(execute_remote)
                else
                    -- we left the target place; reset running so it can run again next time we enter
                    loaderState.running = false
                end
            end
        end)
        if not success then
            warn("[YBA Auto Loader] watcher error:", err)
        end
        wait(CHECK_INTERVAL)
    end
end)

-- user feedback
print("[YBA Auto Loader] active. Watching for place " .. tostring(TARGET_PLACE) .. ". Remote URL: " .. REMOTE_URL)
